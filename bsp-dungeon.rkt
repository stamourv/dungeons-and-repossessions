#lang racket

(require math/array
         "cell.rkt" "grid.rkt" "utils.rkt"
         "dungeon.rkt") ;; TODO eventually merge in with that

(define dungeon-height 18) ; to be easy to display in 80x24, with other stuff
(define dungeon-width  60)

(define (empty-grid)
  (array->mutable-array
   (build-array (vector dungeon-height dungeon-width)
                (lambda _ (new void-cell%)))))


(struct bsp
  (height
   width
   start-pos
   children)) ; (listof bsp?)
;; Note: children have one row/column of overlap, to have abutting walls

(define (show-bsp bsp)
  (define h (bsp-height bsp))
  (define w (bsp-width bsp))
  (define grid
    (array->mutable-array
     (for*/array #:shape (vector h w)
                 ([x (in-range h)]
                  [y (in-range w)])
        #f)))
  (define id 0)
  (define ids "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ")
  (let loop ([bsp bsp])
    (define children (bsp-children bsp))
    (cond [(not (empty? children))
           (for-each loop children)]
          [else ; leaf, draw
           (for* ([dx (in-range (bsp-height bsp))]
                  [dy (in-range (bsp-width  bsp))])
             (define pos (down (right (bsp-start-pos bsp) dy) dx))
             (if (array-ref grid pos) ; already something there, so overlap zone
                 (array-set! grid pos " ")
                 (array-set! grid pos (string-ref ids id))))
           (set! id (add1 id))]))
  ;; actual display
  (with-output-to-string
    (lambda ()
      (for ([row (in-array-axis grid)])
        (for ([cell (in-array row)])
          (display (or cell "*")))
        (newline)))))

(module+ test
  (require rackunit)
  (define (render-grid g) (string-join g "\n" #:after-last "\n"))

  (check-equal? (show-bsp (bsp 5 5 #(0 0) #f))
                (render-grid '("00000"
                               "00000"
                               "00000"
                               "00000"
                               "00000")))
  (check-equal? (show-bsp (bsp 5 5 #(0 0)
                               (list (bsp 5 3 #(0 0) #f)
                                     (bsp 5 3 #(0 2) #f))))
                (render-grid '("00 11"
                               "00 11"
                               "00 11"
                               "00 11"
                               "00 11")))
  (check-equal? (show-bsp (bsp 5 5 #(0 0)
                               (list (bsp 5 3 #(0 0)
                                          (list (bsp 2 3 #(0 0) #f)
                                                (bsp 4 3 #(1 0) #f)))
                                     (bsp 5 3 #(0 2) #f))))
                (render-grid '("00 22"
                               "   22"
                               "11 22"
                               "11 22"
                               "11 22")))
  (check-equal? (show-bsp (bsp 5 5 #(0 0)
                               (list (bsp 5 3 #(0 0)
                                          (list (bsp 2 3 #(0 0) #f)
                                                (bsp 4 3 #(1 0) #f)))
                                     (bsp 5 3 #(0 2)
                                          (list (bsp 3 3 #(0 2) #f)
                                                (bsp 3 3 #(2 2) #f))))))
                (render-grid '("00 22"
                               "   22"
                               "11   "
                               "11 33"
                               "11 33")))
  )


(define min-room-dimension 7) ; TODO tweak
(define max-room-dimension 11)

;; "Partitions" a grid randomly, by repeatedly splitting in two along an axis.
;; Not exactly a partition becase the two parts generated by a split overlap
;; by one row/column. That's to allow adjacent rooms to share walls, to save
;; space, look nicer, and give easy opportunities for connecting rooms.
(define (make-bsp [height    dungeon-height]
                  [width     dungeon-width]
                  [start-pos #(0 0)])
  ;; This threshold for splitting may result in areas that are too small
  ;; for rooms. That's ok, we can filter those out later. We'll end up with
  ;; more areas than we want rooms anyway.
  ;; We may end up with fewer rooms than we need for encounters, in which
  ;; case we can just restart. C'est la vie.
  (define min-can-split           (+ min-room-dimension 3)) ; 3 is arbitrary
  (define can-split-horizontally? (>= width  min-can-split))
  (define can-split-vertically?   (>= height min-can-split))
  ;; prioritize splitting the largest dimension. gives nicer results, IME
  (define split-horizontally? (and can-split-horizontally?
                                   (or (not can-split-vertically?)
                                       (>= width height))))
  (match-define (vector start-x start-y) start-pos)
  (bsp height
       width
       start-pos
       (cond
        [split-horizontally?
         (define split-dy (random-between 3 width)) ; 3 is arbitrary
         (list (make-bsp height (add1 split-dy) start-pos)
               (make-bsp height (- width split-dy) (right start-pos split-dy)))]
        [can-split-vertically?
         (define split-dx (random-between 3 height))
         (list (make-bsp (add1 split-dx) width start-pos)
               (make-bsp (- height split-dx) width (down start-pos split-dx)))]
        [else ; leaf, no children
         '()])))

(define (too-small? bsp)
  (or (< (bsp-height bsp) min-room-dimension)
      (< (bsp-width  bsp) min-room-dimension)))
(define (prune-bsp a-bsp)
  (match-define (bsp height width start-pos children) a-bsp)
  (bsp height width start-pos
       (map prune-bsp (filter (negate too-small?) children))))

(define (bsp-n-areas bsp)
  (define children (bsp-children bsp))
  (if (empty? children)
      1 ; leaf, just the one
      (for/sum ([c (in-list children)]) (bsp-n-areas c))))



(struct room
  (height
   width
   free-cells  ; where monsters or treasure could go
   extension-points)) ; (listof (cons/c pos direction))


(define (generate-rooms [a-bsp (prune-bsp (make-bsp))])
  (define grid
    (array->mutable-array
     (build-array (vector dungeon-height dungeon-width)
                  (lambda _ (new void-cell%)))))
  ;; put a room in each leaf area
  (define rooms
    (let loop ([a-bsp a-bsp])
      (match-define (bsp height width start-pos children) a-bsp)
      (cond [(not (empty? children)) ; recur
             (append-map loop children)]
            [else ; leaf, add a room
             (define-values (free-cells extension-points)
               (for*/fold ([free-cells       '()]
                           [extension-points '()])
                   ([x (in-range height)]
                    [y (in-range width)])
                 (define pos (right (down start-pos x) y))
                 (define (add-wall!) (array-set! grid pos (new wall%)))
                 (cond [(or (and (= x 0) (= y 0)) ; corner wall
                            (and (= x (sub1 height)) (= y (sub1 width))))
                        (add-wall!)
                        ;; not free, and can't expand from corners
                        (values free-cells extension-points)]
                       [(= x 0) ; top wall
                        (add-wall!)
                        (values free-cells
                                (dict-set extension-points pos up))]
                       [(= x (sub1 height)) ; bottom wall
                        (add-wall!)
                        (values free-cells
                                (dict-set extension-points pos down))]
                       [(= y 0) ; left wall
                        (add-wall!)
                        (values free-cells
                                (dict-set extension-points pos left))]
                       [(= y (sub1 width)) ; right wall
                        (add-wall!)
                        (values free-cells
                                (dict-set extension-points pos right))]
                       [else ; inside of room
                        (array-set! grid pos (new empty-cell%))
                        (values (cons pos free-cells) extension-points)])))
             (list (room height width free-cells extension-points))])))
  (values grid rooms))


(module+ main
  ;; generate an example
  (define ex (make-bsp))
  (displayln (show-bsp ex))
  (displayln (show-bsp (prune-bsp ex)))
  (define-values (grid rooms) (generate-rooms (prune-bsp ex)))
  (displayln (show-grid (smooth-walls grid)))

  ;; make sure that we have "enough" rooms with high-enough probability
  ;; (need enough for all encounters, and 6 is currently the max I've seen)
  (define n-tests 1000)
  (printf "~a / ~a have at least 6 rooms\n"
          (for/sum ([i 1000]
                    #:when (>= (bsp-n-areas (prune-bsp (make-bsp))) 6))
            1)
          n-tests)
)

#lang racket

(require racket/random math/distributions
         "cell.rkt" "grid.rkt" "wall-smoothing.rkt" "utils.rkt")

(provide generate-dungeon
         (struct-out room))

(define dungeon-height 18) ; to be easy to display in 80x24, with other stuff
(define dungeon-width  60)

(define (empty-grid)
  (array->mutable-array
   (build-array (vector dungeon-height dungeon-width)
                (lambda _ (new void-cell%)))))


(struct bsp
  (height
   width
   start-pos
   children)) ; (listof bsp?)
;; Note: children have one row/column of overlap, to have abutting walls

(define (show-bsp bsp)
  (define h (bsp-height bsp))
  (define w (bsp-width bsp))
  (define grid
    (array->mutable-array
     (for*/array #:shape (vector h w)
                 ([x (in-range h)]
                  [y (in-range w)])
        #f)))
  (define id 0)
  (define ids "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ")
  (let loop ([bsp bsp])
    (define children (bsp-children bsp))
    (cond [(not (empty? children))
           (for-each loop children)]
          [else ; leaf, draw
           (for* ([dx (in-range (bsp-height bsp))]
                  [dy (in-range (bsp-width  bsp))])
             (define pos (down (right (bsp-start-pos bsp) dy) dx))
             (if (array-ref grid pos) ; already something there, so overlap zone
                 (array-set! grid pos " ")
                 (array-set! grid pos
                             (string-ref ids (modulo id (string-length ids))))))
           (set! id (add1 id))]))
  ;; actual display
  (with-output-to-string
    (lambda ()
      (for ([row (in-array-axis grid)])
        (for ([cell (in-array row)])
          (display (or cell "*")))
        (newline)))))

(module+ test
  (require rackunit)
  (define (render-grid g) (string-join g "\n" #:after-last "\n"))

  (check-equal? (show-bsp (bsp 5 5 #(0 0) '()))
                (render-grid '("00000"
                               "00000"
                               "00000"
                               "00000"
                               "00000")))
  (check-equal? (show-bsp (bsp 5 5 #(0 0)
                               (list (bsp 5 3 #(0 0) '())
                                     (bsp 5 3 #(0 2) '()))))
                (render-grid '("00 11"
                               "00 11"
                               "00 11"
                               "00 11"
                               "00 11")))
  (check-equal? (show-bsp (bsp 5 5 #(0 0)
                               (list (bsp 5 3 #(0 0)
                                          (list (bsp 2 3 #(0 0) '())
                                                (bsp 4 3 #(1 0) '())))
                                     (bsp 5 3 #(0 2) '()))))
                (render-grid '("00 22"
                               "   22"
                               "11 22"
                               "11 22"
                               "11 22")))
  (check-equal? (show-bsp (bsp 5 5 #(0 0)
                               (list (bsp 5 3 #(0 0)
                                          (list (bsp 2 3 #(0 0) '())
                                                (bsp 4 3 #(1 0) '())))
                                     (bsp 5 3 #(0 2)
                                          (list (bsp 3 3 #(0 2) '())
                                                (bsp 3 3 #(2 2) '()))))))
                (render-grid '("00 22"
                               "   22"
                               "11   "
                               "11 33"
                               "11 33")))
  )


(define min-room-height 6) ; maps are more height-constrained
(define min-room-width  9)

;; "Partitions" a grid randomly, by repeatedly splitting in two along an axis.
;; Not exactly a partition becase the two parts generated by a split overlap
;; by one row/column. That's to allow adjacent rooms to share walls, to save
;; space, look nicer, and give easy opportunities for connecting rooms.
(define (make-bsp [height    dungeon-height]
                  [width     dungeon-width]
                  [start-pos #(0 0)])
  ;; This threshold for splitting may result in areas that are too small
  ;; for rooms. That's ok, we can filter those out later. We'll end up with
  ;; more areas than we want rooms anyway.
  ;; We may end up with fewer rooms than we need for encounters, in which
  ;; case we can just restart. C'est la vie.
  (define split-slop              3) ; arbitrary
  (define can-split-horizontally? (>= width  (+ min-room-width  split-slop)))
  (define can-split-vertically?   (>= height (+ min-room-height split-slop)))
  ;; prioritize splitting the largest dimension. gives nicer results, IME
  (define split-horizontally? (and can-split-horizontally?
                                   (or (not can-split-vertically?)
                                       (>= width height))))
  (match-define (vector start-x start-y) start-pos)
  (bsp height
       width
       start-pos
       (cond
        [split-horizontally?
         (define split-dy (random 3 width)) ; 3 is arbitrary
         (list (make-bsp height (add1 split-dy) start-pos)
               (make-bsp height (- width split-dy) (right start-pos split-dy)))]
        [can-split-vertically?
         (define split-dx (random 3 height))
         (list (make-bsp (add1 split-dx) width start-pos)
               (make-bsp (- height split-dx) width (down start-pos split-dx)))]
        [else ; leaf, no children
         '()])))

(define (too-small? bsp)
  (or (< (bsp-height bsp) min-room-height)
      (< (bsp-width  bsp) min-room-width)))
(define (prune-bsp a-bsp)
  (match-define (bsp height width start-pos children) a-bsp)
  (bsp height width start-pos
       (map prune-bsp (filter (negate too-small?) children))))

(define (bsp-n-areas bsp)
  (define children (bsp-children bsp))
  (if (empty? children)
      1 ; leaf, just the one
      (for/sum ([c (in-list children)]) (bsp-n-areas c))))



(struct room
  (pos
   height
   width
   [free-cells #:mutable] ; where monsters or treasure could go
   extension-points)) ; (listof (cons/c pos direction))


(define (add-room! grid start-pos height width)
  (define-values (free-cells extension-points)
    (for*/fold ([free-cells       '()]
                [extension-points '()])
        ([x (in-range height)]
         [y (in-range width)])
      (define pos (right (down start-pos x) y))
      (define (add-wall!) (array-set! grid pos (new wall%)))
      (cond [(or (and (= x 0)             (= y 0)) ; corner wall cases
                 (and (= x 0)             (= y (sub1 width)))
                 (and (= x (sub1 height)) (= y 0))
                 (and (= x (sub1 height)) (= y (sub1 width))))
             (add-wall!)
             ;; not free, and can't expand from corners
             (values free-cells extension-points)]
            [(= x 0) ; top wall
             (add-wall!)
             (values free-cells (dict-set extension-points pos up))]
            [(= x (sub1 height)) ; bottom wall
             (add-wall!)
             (values free-cells (dict-set extension-points pos down))]
            [(= y 0) ; left wall
             (add-wall!)
             (values free-cells (dict-set extension-points pos left))]
            [(= y (sub1 width)) ; right wall
             (add-wall!)
             (values free-cells (dict-set extension-points pos right))]
            [else ; inside of room
             (array-set! grid pos (new empty-cell%))
             (values (cons pos free-cells) extension-points)])))
  (room start-pos height width free-cells extension-points))

(define pillar-prob 0.5)
(define (maybe-add-pillars! r grid)
  (match-define (room start-pos height width free-cells extension-points) r)
  (define shortest-dim (min height width))
  (define longest-dim (max height width))
  (when (and (< (random) pillar-prob)
             (>= shortest-dim 7)) ; big enough to not be too cramped
    (define pillar-poss/shortest-dim
      (cond [(>= shortest-dim 8) ; go with 2 rows/columns of pillars
             ;; split the 3 aisles evenly, but allow middle to be larger
             (define adjusted-dim (- shortest-dim 4)) ; 4 = 2 walls, 2 pillars
             (define aisle-width  (quotient adjusted-dim 3))
             (define middle-width (- adjusted-dim (* 2 aisle-width)))
             (unless (= (+ aisle-width middle-width 2) ; sanity check
                        (- shortest-dim (+ aisle-width 2)))
               (error "pillar-poss/shortest-dim: got my math wrong"))
             (list (+ aisle-width 1) ; first wall, aisle
                   (- shortest-dim (+ aisle-width 2)))] ; from the other end
            [else ; shortest-dim = 7, just one column
             '(3)]))
    ;; potentially more in longest dimension. hard-coded to look nice
    (define pillar-poss/longest-dim
      (case longest-dim ; goes up to 15, with current BSP generation
        [(7)  '(3)] ; |  #  |
        [(8)  '(2 5)] ; | #  # |
        [(9)  '(2 6)] ; | #   # |
        [(10) '(3 6)] ; |  #  #  |
        [(11) (random-ref '((3 7) (2 5 8)))] ; |  #   #  | / | #  #  # |
        [(12) '(3 8)] ; |  #    #  |
        [(13) '(3 6 9)] ; |  #  #  #  |
        [(14) (random-ref '((4 9) (2 5 8 11)))]; |   #    #   | / | #  #  #  # |
        [(15) '(3 7 11)])) ; |  #   #   #  |
    (match-define (vector start-x start-y) start-pos)
    (for* ([pos-short (in-list pillar-poss/shortest-dim)]
           [pos-long  (in-list pillar-poss/longest-dim)])
      (define height-shortest? (= height shortest-dim))
      (define pos (vector (+ start-x (if height-shortest? pos-short pos-long))
                          (+ start-y (if height-shortest? pos-long pos-short))))
      (array-set! grid pos (new pillar%))
      (set-room-free-cells! r (remove pos (room-free-cells r))))))


(define (generate-rooms [a-bsp (prune-bsp (make-bsp))])
  (define grid
    (array->mutable-array
     (build-array (vector dungeon-height dungeon-width)
                  (lambda _ (new void-cell%)))))
  ;; put a room in each leaf area
  (define rooms
    (let loop ([a-bsp a-bsp])
      (match-define (bsp height width start-pos children) a-bsp)
      (cond
       [(not (empty? children)) ; recur
        (append-map loop children)]
       [else ; leaf, add a room
        (define r (add-room! grid start-pos height width))
        (maybe-add-pillars! r grid)
        (list r)])))
  (values grid rooms))


;; union-find data structure (dumb linear version)
(struct component (elt parent) #:mutable)
(define (singleton-component x)
  (define res (component x #f))
  (set-component-parent! res res)
  res)
(define (component-root c)
  (if (equal? (component-parent c) c)
      c
      (component-root (component-parent c))))
(define (component-union! x y)
  (set-component-parent! (component-root x) (component-root y)))
(define (same-component? x y)
  (equal? (component-root x) (component-root y)))

(define (empty-cell? grid pos)
  (is-a? (grid-ref grid pos) empty-cell%))
(define (door? grid pos)
  (is-a? (grid-ref grid pos) door%))
(define (wall? grid pos)
  (is-a? (grid-ref grid pos) wall%))

(define (dir->door dir)
  (if (vertical? dir) horizontal-door% vertical-door%))

(define open-doorway-prob 0.4)
(define (maybe-open-doorway door-kind)
  (define dist (discrete-dist (list empty-cell% door-kind)
                              (list open-doorway-prob (- 1 open-doorway-prob))))
  (new (sample dist)))

(define (add-corridors grid rooms)
  (define connected-pairs '()) ; (listof (list/c room? room?))
  (define (directly-connected? r1 r2)
    (or (member (cons r1 r2) connected-pairs)
        (member (cons r2 r1) connected-pairs)))
  (define rooms->connected-components
    (for/list ([r (in-list rooms)]
               [i (in-naturals)])
      (cons r (singleton-component i))))
  (define (connect-rooms! r1 r2)
    (set! connected-pairs (cons (cons r1 r2) connected-pairs))
    (component-union! (dict-ref rooms->connected-components r1)
                      (dict-ref rooms->connected-components r2)))
  (define (all-connected?)
    (= 1 (length (remove-duplicates
                  (map component-root (map cdr rooms->connected-components))))))

  ;; first, try opening doors between abutting rooms
  (for ([p (in-list (cartesian-product rooms rooms))])
    (match-define (list r1 r2) p)
    (unless (or (equal? r1 r2)
                ;; have we seen that pair before (in the other order)
                (member (cons r2 r1) connected-pairs))
      (define common ; get the positions first (extension points have dir too)
        (set-intersect (map car (room-extension-points r1))
                       (map car (room-extension-points r2))))
      (define possible-doors
        (filter values
                (for/list ([pos (in-list common)])
                  (cond [(and (empty-cell? grid (up   pos))
                              (empty-cell? grid (down pos)))
                         (cons pos horizontal-door%)]
                        [(and (empty-cell? grid (left  pos))
                              (empty-cell? grid (right pos)))
                         (cons pos vertical-door%)]
                        [else #f]))))
      (when (not (empty? possible-doors))
        (match-define (cons pos door-kind) (random-ref possible-doors))
        (connect-rooms! r1 r2)
        (array-set! grid pos (maybe-open-doorway door-kind)))))

  ;; start digging corridors at random, in the hope of connecting everyone
  ;; (and introducing some cycles)
  (define all-extension-points ; (listof (list/c pos dir room))
    (for*/list ([r (in-list rooms)]
                [e (in-list (room-extension-points r))])
      (match-define (cons pos dir) e)
      (list pos dir r)))
  (for ([e (in-list (shuffle all-extension-points))]
        ;; stop when everyone is connected
        ;; still likely to have cycles (which we want) because we proceed
        ;; in random order, but less likely to have way too many corridors
        #:break (all-connected?))
    (match-define (list start-pos dir start-room) e)
    (define end-pos+corridor-id
      (let loop ([pos (dir start-pos)])
        (cond [(not (within-grid? grid pos)) ; out of bounds, give up
               #f]
              [(or (empty-cell? grid pos) (door? grid pos))
               ;; we're digging into an adjacent room, not useful
               #f]
              [(wall? grid pos) ; we hit something
               (cond [(dict-ref all-extension-points pos #f) =>
                      ;; hit another room. if we're not already directly
                      ;; connected to it, and if we're entering that wall
                      ;; from the right direction, dig that corridor
                      (lambda (dir+room)
                        (define end-room (second dir+room))
                        (cond
                         [(and (not (directly-connected? start-room end-room))
                               (opposite-directions? dir (first dir+room)))
                          ;; add the corridor to the room graph
                          (define corridor-id (gensym))
                          (set! rooms->connected-components
                                (dict-set rooms->connected-components
                                          corridor-id
                                          (singleton-component corridor-id)))
                          (connect-rooms! start-room corridor-id)
                          (connect-rooms! end-room   corridor-id)
                          ;; count the two rooms as directly connected,
                          ;; to avoid spawing more corridors between them
                          (connect-rooms! start-room end-room)
                          (cons pos corridor-id)]
                         [else #f]))]
                     [else ; not an extension point (maybe a corner), give up
                      #f])]
              [else
               (loop (dir pos))]))) ; keep digging
    (when end-pos+corridor-id ; actually dig the corridor
      (match-define (cons end-pos corridor-id) end-pos+corridor-id)
      (array-set! grid start-pos (maybe-open-doorway (dir->door dir)))
      (array-set! grid end-pos   (maybe-open-doorway (dir->door dir)))
      (match-define (vector start-x start-y) start-pos)
      (match-define (vector end-x   end-y)   end-pos)
      ;; to make corridors valid end points for other corridors, need to add
      ;; them as possible extension points
      ;; also useful to avoid having one room dig corridors into the same
      ;; corridor multiple times (rooms recognize that they are already
      ;; connected to that corridor, even though it's not a real room)
      ;; Note: they won't be actually used to start new corridors, since
      ;;   we've already shuffled the original extension points
      (define (add-extension-point! p dir)
        (set! all-extension-points
              (cons (list p dir corridor-id) all-extension-points)))
      (if (member dir (list up down))
          (for ([x (in-range (add1 (min start-x end-x)) (max start-x end-x))])
            (define pos (vector x start-y))
            (array-set! grid pos         (new empty-cell%))
            (array-set! grid (left pos)  (new wall%))
            (add-extension-point! (left pos) left)
            (array-set! grid (right pos) (new wall%))
            (add-extension-point! (right pos) right))
          (for ([y (in-range (add1 (min start-y end-y)) (max start-y end-y))])
            (define pos (vector start-x y))
            (array-set! grid pos        (new empty-cell%))
            (array-set! grid (up pos)   (new wall%))
            (add-extension-point! (up pos) up)
            (array-set! grid (down pos) (new wall%))
            (add-extension-point! (down pos) down)))))

  ;; if everyone is not connected, give up on this map
  ;; will have to restart from scratch (BSP generation)
  ;; this could happen if, e.g., one room does not share an x or y coordinates
  ;; with any other (or if the ones it shares would hit a corner)
  ;; very unlikely
  (and (all-connected?)
       (cons grid rooms)))


(define (generate-dungeon min-n-rooms)
  (define bsp
    (let loop ()
      (define bsp (prune-bsp (make-bsp)))
      (if (< (bsp-n-areas bsp) min-n-rooms)
          (loop) ; not enough rooms, try again
          bsp)))
  (define-values (g1 rs1)
    (generate-rooms bsp))
  (match (add-corridors g1 rs1)
    [`(,grid . ,rooms)
     (values (smooth-walls grid)
             rooms)]
    [#f ; failed, try again
     (log-warning "generate-dungeon: had to restart")
     (generate-dungeon)]))


(module+ main
  ;; generate an example
  (define ex (make-bsp))
  (displayln (show-bsp ex))
  (displayln (show-bsp (prune-bsp ex)))
  (define-values (grid rooms) (generate-rooms (prune-bsp ex)))
  (displayln (show-grid (smooth-walls (car (add-corridors grid rooms)))))

  ;; make sure that we have "enough" rooms with high-enough probability
  ;; (need enough for all encounters, and 6 is currently the max I've seen)
  (define n-tests 1000)
  (define dungeons
    (for/list ([i (in-range n-tests)])
      (prune-bsp (make-bsp))))
  (define histogram
    (for/fold ([hist '()])
        ([d (in-list dungeons)])
      (define n (bsp-n-areas d))
      (dict-update hist n add1 0)))
  (displayln "# room distribution")
  (for ([(k v) (in-dict (sort histogram < #:key car))])
    (printf "  ~a = ~a\n" (~a k #:width 2) v))
  (newline)
  (define-values (min-dim max-dim)
    (for/fold ([min-dim +inf.0]
               [max-dim -inf.0])
        ([d (in-list dungeons)])
      (let loop ([a-bsp d] [min-dim min-dim] [max-dim max-dim])
        (match-define (bsp height width start-pos children) a-bsp)
        (if (empty? children)
            (values (min min-dim width height) (max max-dim width height))
            (for/fold ([min-dim min-dim]
                       [max-dim max-dim])
                ([c (in-list children)])
              (loop c min-dim max-dim))))))
  (printf "room dimensions: min = ~a ; max = ~a\n" min-dim max-dim)
)
